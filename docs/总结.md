## h5新特性

* 用于绘画canvas元素
* 用于媒介回放的video和audio元素
* 语义化更好的元素内容（header、footer、nav、article、section3）
* 表单控件（date、calendar、time、Email、url、search）
* 本地离线存储（localstorage、sessionstorage）

## h5的特点

* h5最大的优势就是跨平台，开发者无需太多的适配工作，用户无需下载，打开一个网页即可
* h5页面开发简单，开发成本低，维护简单
* h5兼容性好

## c3有什么新特性

* 文本阴影text-shadow
* 圆角阴影box-shadow
* 边框图片border-image
* 边框圆角border-radius
* 背景大小background-size
* 背景原点background-origin
* 多背景background:url(), url(), url()
* 背景区域裁切background-clip
* 渐变background-image:linear-gradient
* 过度transition
* 动画

## call原生

```js
Function.prototype.newCall = function(context, ...parameter) {
    if (typeof context === 'object' || typeof context === 'function') {
        context = context || window
    } else {
        context = Object.create(null)
    }

    context.fn = this; 
    // 此时这个this指的是sayhi这个函数
    // 将sayhi函数（方法）挂载到context上
    // debugger

    context.fn(...parameter); 
    // 展开运算符接收剩余的参数 然后将接收到的参数作为sayhi函数的实参
    // 调用context上的fn方法，也就是sayhi函数
    // debugger
    
    delete context.fn;
    // 最后将这个属性删除
}
let person = {
    name: 'Abiel'
}
function sayHi(age,sex) {
    console.log(this.name, age, sex);
}
sayHi.newCall (person, 25, '男'); // Abiel 25 男
```



## key的作用

> key的作用就是给vnode生成一个唯一的标识，可以更快的，更准确的拿到oldvnode中对应的vnode节点

## 盒子水平居中

```css
方式一：
.f {
    width: 200px;
    height: 200px;
    background: red;
    display: flex;
    justify-content: center;
    align-items: center;
 }

.s {
    width: 100px;
    height: 100px;
    background-color: blue;
    /* position: absolute; */
    /* top: 50%; */
    /* left: 50%; */
    /* margin-left: -50px; */
    /* margin-top: -50px; */
    /* transform: translateY(-50%) */
 }
方式二：
.f {
    width: 200px;
    height: 200px;
    background: red;
    position: relative;
 }
.s {
    width: 100px;
    height: 100px;
    background-color: blue;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
 }

方式三：
.parent{   
   position: relative;   
 }   
.child{   
   position: absolute;   
   left: 50%;   
   top: 50%;   
   transform: translate(-50%,-50%);   
}
```



## 数组扁平化

```js

function flatten(arr) {
    while(arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
    }
    return arr
}
```

## BFC

```html
BFC是一个独立的环境，不受外界的影响
如何创建一个一个BFC：
    1、float的值不是none。
    2、position的值不是static或者relative。
    3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex
    4、overflow的值不是visible
可以解决：
	1、避免外边距折叠
	2、能包含浮动，解决容器高度不能撑开高度的问题
```

## let、const、var

>let const var  的区别
>let和const没有变量提升，
>
>let和const具有块级作用域，
>
>let和const不能通过window调用，
>
>const不能修改值， 
>
>const有初始值

## vue常见指令

>v-html、v-text、v-if、v-show、v-for、v-on、v-bind、v-model

## link和import的区别

>1、从属关系区别：@import是css提供的语法规则，只有导入样式的作用；link是html提供的标签，不仅可以css文件，还可以定义rss、rel连接属性
>
>2、加载顺序区别：加载页面时，link标签引入的css被同时加载；@import引入的css将在页面加载完毕后被加载
>
>3、兼容性：@import是css2.1才有的语法，故只可在ie5+才能识别；link标签作为html元素，不存在兼容性问题
>
>4、DOM可控制性区别：可以通过js操作DOM，插入link标签来改变演示；由于DOM方法是基于文档的，无法使用@import的方式插入样式
>
>5、权重区别：link引入的样式权重大于@import引入的样式

## ajax的优缺点和axios

>axios是基于promise的http库，用于浏览器和node中，
>
>axios具有的特性：从浏览器中创建XMLHttpRequest，支持promiseAPI，拦截请求和响应，自动转换JSON数据，
>
>ajax的缺点：ajax不合符MVVM的浪潮，jquery真个项目比较大，单纯的使用ajax引入jquery不合理

## vuex的五个属性，分别是什么

>vuex是一个专门为vue.js应用设计的状态管理架构，同意管理和维护各个vue组件的可变化状态
>
>什么时候使用vuex：多个视图依赖于同一状态，来自不同视图的行为需要变更为同一状态，例如购物车
>
>state、mutation、actions、getters、moudles
>
>state：基本数据
>
>​			如何访问：在js中使用  this.$store.state.count
>
>​									在模板中直接$store.state.conut访问
>
>mutation：提交更改数据的方法，同步
>
>​						1、commit 提交 mutation
>
>​						2、在 mutation 中修改 state 状态
>
>​						3、state 状态改变，驱动视图更新
>
>actions：像一个装饰器，包裹mutations，使之可以异步
>
>​						1、dispatch 发起 action
>
>​						2、在 action 中执行异步操作
>
>​						3、action 中异步操作执行结束之后，commit 提交 mutation
>
>​						4、在 mutation 中修改 state 状态
>
>​						5、state 状态改变，驱动视图更新
>
>getters：从基本数据派生的数据
>
>modules：Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割

## v-if和v-show的区别

>`v-if` 有更高的**`切换开销`**，而 `v-show` 有更高的初始渲染开销

## 解决跨域的方法，实现跨域的原理

>通过JSONP，有一个缺陷就是只能get，而且会把请求内容发送到url中导致安全性极低
>
>后台使用cors
>
>window.name
>
>原理：通过srcipt标签上的src属性可以获取任何域下的js脚本，服务器端不再返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域
>
>jsonp优点：完美解决在测试或者开发中获取不同域下的数据，用户传递一个callback参数给服务器，然后服务器返回数据时会将这个callback参数作为函数名来包裹住json数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了，简单来说数据的格式没有发生

## 同源策略限制以下几种行为

>1) Cookie、LocalStorage 和 IndexDB 无法读取
>
> 2.) DOM 和 Js对象无法获得 
>
> 3.) AJAX 请求不能发送

## 深浅拷贝

>浅拷贝只是拷贝最外边那一层，只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享一块内存

```js
var obj = {
    name : '张三丰',
    age : 22
};

var newObj = {};
for (key in obj) {
    newObj[key] = obj[key];
}
```

>深拷贝就是能够实现真正意义的数组和对象的拷贝，新对象和原对象不共享内存，修改新对象不会改到原对象

```js
var obj = {
    name : '1张三丰',
    age : 22,
    messige : {
        sex : '男',
        score : 16
    },
    color : ['red','purple','qing']
}

function copy (newObj,obj) {
    for (let key in obj) {
        if(obj[key] instanceof Array) {
            newObj[key] = []
            copy(newObj[key],obj[key])
        } else if (obj[key] instanceof Object) {
            newObj[key] = {}
            copy(newObj[key],obj[key])
        } else {
            newObj[key] = obj[key]
        }
    }
}


还有一种方法：JSON.parse(JSON.stringify(obj))
```

## 为什么要使用base64

>为了方便把含有不可见字符串的信息用可见字符串表示出来

## typeof 和 instance of区别

```js
typeof的返回值是一个字符串，返回的字符串表达了程序员想要输出的变量类型（number，string，boolean，object，function，undefind）
var obj = [1,2]
console.log(typeof obj) // object
无论引用的是什么类型的对象，他都会返回‘object’，这个时候就要用到instanceof运算符，返回布尔值

注意：数组Array是对象Object的一个子类，所以 a instanceof Object的返回值是 true
```

## localStorage和sessionStorage的方法

>setItem、getItem和removeItem

## 怎么判断浮点数相等

```
1、精度判断法
var delta = 1e-5; // 定义精度精确到0.00001
var a = 0.1;
var b = 0.2;
var sum = 0.3;
// 判断相差小于精度就认为相等
if(a + b - sum < delta) {
    console.log('a + b == sum');
}
2、
NumberObject.toFixed(num); //num代表要保留的小数位数。
console.log(1.35.toFixed(1)); // 1.4 正确
console.log(1.335.toFixed(2)); // 1.33 错误
Number.prototype.toFixed = function (s) {
     var times = Math.pow(10, s);
     //如果是正数，则+0.5，是负数，则-0.5
     const adjust = this >= 0 ? 0.5 : -0.5;
     var des = this * times + adjust;
     des = parseInt(des, 10) / times;
     return des + '';
}
```

## 原型链

>每一个对象都有一个原型___proto___，这个原型还可以有他自己的原型，形成一个原型链，proto是对象独有的
>
>prototype属性：他就是函数所独有的，就是一个函数指向另一个对象。这个属性就是一个指针，指向一个对象，这个对象包含所有实例共享的属性和方法。
>
>

## vue.nextTick

```
需要在DOM更新之后在执行一段代码时，可以借助nextTick实现。将视图更新后的操作放在nextTick的回调中执行，其底层通过微任务的方式执行回调，可以保证 DOM 更新后才执行代码。
而这个操作需要使用随数据改变而改变的DOM结构的时候
```

## 路由传参

```
1、路由配置文件中path:'child/:num'
   进行路由导航，传递参数
   接收：this.$route.params.num
2、直接使用$router.push实现携带参数的跳转
   this.$touter.push({ path:`/child/${参数}` })
   接收：this.$route.params.id
3、通过路由属性中的name来确定匹配的路由，通过params来传递参数
	this.$router.push({
		name:'childView',
		params: {
			id:1
		}
	})
4、使用path来匹配路由，然后通过query来传递参数
this.$router.push({
	path: '/child',
	query: {
		id: 1
	}
})
```

## SPA的特点

>优点：
>
>1、切换页面时，不需要再去经过网络请求，用户体验好
>
>2、完全组件化，由于只有一个页面，所以原来属于一个个页面的规则被归类为一个个组件			
>
>缺点：
>
>1、首屏加载比较慢
>
>2、不利于seo

## SPA的实现原理

>- SPA要实现 能够在**`前端自由切换模块`** 
>- SPA要能**`记忆当前切换的模块`**,并且刷新页面模块依然还在当前视图
>- SPA要实现在**`前端切换模块`**时,不能**`引起页面刷新`**,否则页面内容会被重置
>
>结论：
>
>* 可以通过页面的锚链接来实现
>* hash位于连接地址 # 之后
>* hash值时url地址的一部分，会存储在页面地址上，我们可以获取到
>* 可以通过hash值，就可以根据不同值进行不同的模块切换

## 重定向

>redirect

## vue2.0和3.0

>2.0创建项目：vue init webpack-simple 项目名称
>
>3.0创建项目：vue create 项目名称

## activated 和 deactivated

>当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。
>
>deactivated：每次离开当前组件都会执行
>
>activated：每次切换回来都在执行

## **beforeRouteLeave**

>导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将`setInterval`销毁，防止离开之后，定时器还在调用。

## 重绘和回流

>- 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。
>- 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）
>
>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，
>
>- 添加或者删除可见的DOM元素；
>- 元素尺寸改变——边距、填充、边框、宽度和高度
>- 内容变化，比如用户在input框中输入文字
>- 浏览器窗口尺寸改变——resize事件发生时
>- 计算 offsetWidth 和 offsetHeight 属性
>- 设置 style 属性的值

## 性能优化策略

>JS优化： `<script>`
>
>- defer属性： 用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
>- async属性： HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。
>
>CSS优化： `<link>` 标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能

## js判断是否为数组

```js
Object.prototype.toString.apply([]) === '[object Array]'
```

## 移动端兼容性问题

>移动端的兼容问题
>ios端
>1.input标签，设置type=button，disabled为true时不起效果，解决方案opacticy=1
>2.给非点击按钮注册点击事件时，需要设置
>cursor:pointer
>3.new Date日期格式时，-不能识别，得换成/
>h1等不起效果
>高写成百分比不起效果
>
>4.移动端300ms延迟
>解决方案:fastclick和tap.js

## css3新增选择器

```
属性选择器
结构伪类选择器
1、E:nth-last-child(n)  匹配元素类型为E且是父元素的倒数第n个子元素
2、E:nth-last-child(n)：匹配元素类型为E且是父元素的倒数第n个子元素（与上一项顺序相反）
3、E:first-child：匹配元素类型为E且是父元素的第一个子元素
4、E:last-child：匹配元素类型为E且是父元素的最后一个子元素
5、E:only-child：匹配元素类型为E且是父元素中唯一的子元素
6、E:nth-of-type(n)：匹配父元素的第n个类型为E的子元素
7、E:nth-last-of-type(n)：匹配父元素的倒数第n个类型为E的子元素（与上一项顺序相反）
8、E:first-of-type：匹配父元素的第一个类型为E的子元素
9、E:last-of-type：匹配父元素的最后一个类型为E的子元素
10、E:only-of-type：匹配父元素中唯一子元素是E的子元素
11、E:empty 选择一个空的元素
12、E:enabled 可用的表单控件
13、E:disabled 失效的表单控件
14、E:checked 选中的checkbox
15、E:not(s) 不包含某元素
16、E:nth-child(n) 匹配元素类型为E且是父元素的第n个子元素
```

## 解决移动端点击300ms延迟

```
npm i fastclick
在main.js中
import fastClick from 'fastclick'
fastClick.attach(document.body)
```

## 移动端REM适配

```js
npm install postcss-pxtorem --save-dev
npm install amfe-flexible --save
在main.js中引入   import  'amfe-flexible'
在postcssrc.js中配置
	module.exports = {
      "plugins": {
        'autoprefixer': {
          browsers: ['Android >= 4.0', 'iOS >= 7']
        },
        'postcss-pxtorem': {
          rootValue: 37.5,
          propList: ['*']
        }
      }
    }
```

## 组件会被复用

>watch监测数据，$route对象

## vue的优点

>1、不需要像html页面那样频繁的操作真实的dom元素，它本身都是虚拟dom跟数据进行捆绑，降低了性能消耗
>
>2、**VUE的特性**
>		轻量级的框架
>		双向数据绑定，数据驱动视图更新，视图变化驱动数据变化
>		指令
>		插件化

## vue双向绑定的原理

>Vue的双向数据绑定原理是什么？ vue.js 是采用数据劫持结合发布者‐订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter， getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

## 聊聊你对Vue.js的template编译的理解

>* 简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
>* 详情步骤：
>  * 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现 形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并 option。
>  * 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是 VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）

## 圣杯布局和双飞翼布局的区别

>其本质是一样的，都是解决左右定宽，中间自适应的问题

* 如果中间盒子的宽度小于左侧盒子的宽度，就会发生混乱
* 而双飞翼布局不会

双飞翼布局

```css
.main > div {
    float: left;
}
.left {
    width: 200px;
    background: red;
    margin-left: -100%;
}
.right{
    width: 200px;
    background: blue;
    margin-left: -200px;
}
.middle{
    width: 100%;
    background: yellow;

}
.content{
    margin-left: 200px;
    margin-right: 200px;
}

<div class="main">
  <div class="middle">
    <div class="content">
    中间
    </div>
  </div>
  <div class="left">
    左边
  </div>
  <div class="right">
    右边
  </div>
</div>
```

## 移动端自适应屏幕的方法

>宽度和字体大小，左右编剧间距等使用vw单位
>
>高度、行高、上下边距间距都使用vh单位

# 项目

>面包屑，分页（懒加载），账户信息（post和get区别），404页面，登陆（表单验证，前置守卫，登陆后才能进入主页面）
>
>git：
>
>分支发开，master上线，

## tab栏实现

* 原生

```js
1、先将所有tab栏的样式移除掉（使用for循环，移除样式classlist.remove)
2、再将当前点击的项加上classlist.add
3、切换tab时，底下显示的内容问题
	使用for循环，给所有的div移除classlist（display：block），默认给第一个加上
    获取当前移入项的index自定义属性，给当前div加上一个classlist.add
```

* vue

```js
使用v-for循环一个数组，注册点击事件传出来index，保存在data中(dataIndex)
使用v-bind:class='{active: dataIndex == index}'，来决定他的显隐，绑定对象时，后边跟的是布尔值
```

## vue项目切换路由时出现的问题

```js
const originalPush = Router.prototype.push
Router.prototype.push = function push (location) {
  return originalPush.call(this, location).catch(err => err)
}
主要是捕捉这个错误
```

## 面包屑实现

```
<el-breadcrumb separator-class="el-icon-arrow-right">
  <el-breadcrumb-item :to="{ path: '/' }">首页</el-breadcrumb-item>
  <el-breadcrumb-item>
    <slot name="title"></slot>
  </el-breadcrumb-item>
</el-breadcrumb>

// 要在全局注册：vue.component('bread-crumb', breadCrumb)
// 使用具名插槽，谁用的话，就在调用的地方，使用template标签，使用slot插槽，写上slot='title'

<template slot="title">账户信息</template>
```

## 大数字问题

>后端传回的id数字超过了前端的**`最大安全数字`**的限制,导致JSON.parse以及其他运算失败.需要第三方的转化包
>
>后端 => 前端 => 字符串 =>对象 => JSON.parse() => 如果超出了最大安全数字 => 计算偏差 =>JSON.parse不精确(一旦超过最大安全整数)  =>  axios 自动调用的  => 转化方法 =>json.parse()
>
>使用 jsonBigint 来解决
>
>axios.defaults.transformResponse = [*function* (*data*) {
>
>  // 对 data 进行任意转换处理
>
>  return data ? jsonBigint.parse(data) : {}
>
>}]

## eventbus通信

```js
1、在更改数据的地方，引入eventbus，使用eventbus.$emit('事件')
2、在想要同步更改数据的地方使用引入eventbus，在created中，使用eventbus.$on('抛出的事件',() => 调用事件)
```

## 移动端触摸事件

```
touchstart：手指触摸到一个 DOM 元素时触发。
 
touchmove：手指在一个 DOM 元素上滑动时触发。

touchend：手指从一个 DOM 元素上移开时触发。
```

```
移动端项目使用于哪些系统
```

## 箭头函数和普通函数的区别

>1、箭头函数相当于匿名函数，并且简化了函数定义。一种是只包含了一个表达式，{}和return 省略掉了。还有一种可以包括多条语句，不能省略{} 和return
>
>2、箭头函数是匿名函数，不能作为构造函数，不能使用new
>
>3、箭头函数不能绑定arguments，取而代之用rest参数
>
>4、箭头函数不能绑定this，会捕捉其所在的上下文的this值，作为自己的this值
>
>5、箭头函数通过call或者apply方法调用时，对this并没有影响
>
>6、箭头函数没有原型属性

```js
let obj2 = {
            a: 10,
            b: function(n) {
                let f = (n) => n + this.a;
                return f(n);
            },
            c: function(n) {
                let f = (n) => n + this.a;
                let m = {
                    a: 20
                };
                return f.call(m,n);
            }
};
console.log(obj2.b(1));  // 11
`console.log(obj2.c(1)); // 11`   ???????????????
```

## every、every、filter

```js
var a = [1,2,3,4,1]

a.every(item => item == 1) // false

every是都满足了条件，才会返回true

三者都不改变原数组，filter返回满足条件的数组，some和every都返回布尔值，而some只要有满足的条件就返回true
```

## map、forEach

>map和foreach都不改变原来的数组，map返回一个新数组
>
>foreach则没有返回值
>
>foreach执行效率要比map高

## webpack

```js
1、配置打包模式 module.exports = { mode: 'development' } 		development开发模式、production:生产模式

2、配置入口和出口文件

    const ph = require('path')

    module.exports = {
      // 1) 给项目配置入口文件路径名
      entry: ph.resolve('./src/main.js'), 
      // 2) 给项目配置出口文件路径名
      output: {
        path: ph.resolve( './dist'), // 定义出口文件"目录"
        filename: 'bundle.js' // 定义出口"文件名称"
      }
    }
```



## vue-cli帮我们干了什么

>用于自动生成vue.js+webpack的项目模板，核心就是webpack，vue-router是vue路由插件，支持单页面应用，vue-loader是webpack下loader插件，可以把   .vue 文件输出成组件

## 实现数组乱序的方法

```js
function shuffle(arr) {
    let m = arr.length
    while(m > 1) {
        let index = Math.floor(Math.random()*m--);
        [arr[m], arr[index]] = [arr[index], arr[m]]
    }
    return arr
}
var arr = [1,2,3,4,5,6,7,8,9]
console.log(shuffle(arr))

// 实现思路：先获取随机数，为的是得到下标，然后根据下标实现对数组的赋值，从最后一个开始交换
```

 如果深拷贝中出现obj.a=obj这种情况会报错 怎么解决

## cookie、sessionStorage、localStorage

>cookie的作用就是与服务器进行交互，好多浏览器限制一个站点最多保存20个cookie，一个cookie的大小为4kb
>
>web Storage 有localStorage sessionStorage，localStorage是永久性储存，如果不手动删除的话，就会一直保存在本地；sessionStorage仅仅是会话级别的存储

## 绝对定位和相对定位

>relative：相对于原来位置移动，元素设置此属性之后仍然处在文档流中，不影响其他元素的布局
>
>absolute：元素会脱离文档流，如果设置偏移量，会影响其他元素的位置定位；在父元素没有设置相对定位或者绝对定位的情况下，元素相对于根元素定位

## em和rem

>px：相对长度单位。像素px是相对于显示器屏幕分辨率而言的
>
>em：是相对长度单位。其相对于当前对象内文本的font-size，如果当前文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸
>
>​		特点：em的值并不是固定的
>
>​						em会继承父级元素的字体大小
>
>rem是相对大小，根据html根元素的font-size来设置

## 全局作用域、局部作用域、块级作用域

>全局作用域：在任何地方都可以访问到的就是全局作用域，在js中  {}  外面的作用域，称之为全局作用域。
>
>* var和let变量在全局作用域中都是全局变量
>
>局部作用域：只在固定的代码片段内可以访问到的变量，例如函数内部。在js函数后面  {}  中的作用域，称之为局部作用域
>
>* 无论是通过var还是let定义在局部作用域的都是局部变量
>
>块级作用域：
>
>* 在块级作用域中定义的变量是全局变量
>* 在局部作用域中通过var定义的变量是局部变量

## 组件缓存

>1、在路由出口处使用 keep-alive 标签，使用   include   缓存需要缓存的组件，值为组件的name值。
>
>exclude   是不包含当前写的name值的组件，其他会被缓存起来
>
>2、在路由中使用meta属性 meta: {  keepAlive: true  }

## promise的状态

>promise的三种状态：pending / reslove/ reject
>
>pending就是未决；resolve就是成功；reject就是拒绝
>
>

## 过滤器用处

>可以用在插值表达式和v-bind中

## watch

>watch监听的是data中的数据，不可以使用箭头函数。因为箭头函数绑定了父级作用域的上下文，所以this不会预期的指向vue实例
>
>比如当data数据从父组件传递给子组件，子组件接受，**然后这个值再次在父组件发生变化的时候**，**dom元素重新渲染页面**，就要用watch在子组件监听这个变化。

## 检验规则

>手动校验：校验整个表单规则，使用validate
>
>自定义校验：validator，例如复选框
>
>自动校验：校验单个表单数据；:rules="loginRules"  loginRules  定义校验规则，给每一个  el-form-item  写一个prop属性，值为要校验的字段名
>
>







项目描述：

* 登陆页面
  * 校验：自动校验，定义一个校验规则，使用rules属性绑定到form表单上，再给每一项添加一个prop属性，属性值为要校验的字段名。使用validate校验整个表单，获取表单的dom节点，validate是一个方法，里边有一个参数，判断是否isOk，如果ok了再去发请求，将请求获得到的token存到本地，跳转到首页。
* 前置守卫：
  * 引入第三方插件，在路由跳转前，使用nprogress.start开启进度条
  * 使用  router.beforeEach  做前置守卫，里边有三个参数，to，from，next，使用to.path.startswith来判断是不是以  /home  开头的，如果是是的话，在进行下边的判断，看看本地是不是有token，如果没有token的话，就跳到登录页，如果有的胡啊，就next
* 后置守卫：
  * 在后置守卫处，使用nprogress.done关闭进度条
* 请求拦截：
  * 先从本地获取token，然后再注入请求头
* 响应拦截：
  * 对响应数据做处理，获取失败的状态码，提示一个messgae。