## JSON

> 从后端拿到的是php数组，先转成json格式，通过json的属性转成js数据

> json本质是字符串,所以要用下边的方式转一下

```js
var data = json.parse(this.response);

后边有一个responseType属性，根据该属性的值，来处理JS能够识别的数据
写法：xhr.responseType = 'json';
这后边还可以是 """--空、text--文本、json--JSON数据格式、document--文档对象
```

### 数据类型

* null
* number
* boolean
* string
* object

```js
 {
    "name": "zce",
    "age": 18,
    "gender": true,
    "girl_friend": null,
    "arr": []
  }
```

* array

```js
  ["zhangsan", "lisi", "wangwu"]
```

**注意**

* json属性名称必须用双引号
* json没有undefined
* json中只能有一个完整的数组，对象 



服务器返回的xml格式的数据，和document对象一样，所以处理方式也是一样的 



获取文本节点childNodes

输出文本节点的值.nodeValue



children非w3c标准，查找的子节点，只包含元素节点

childNodes查找的子节点，包含文本节点和元素节点



## 模板引擎解决性能问题

> 首先要引入一个js文件

```js
1、定义模板
<script id = "test" type = "text/html">
	<h1>{{title}}</h1>
</script>

<script>
	var html = template('test',{
     title:'写上文字' 
	});
	
	console.log(html);
	
	// 放入body中
	document.body.innerHTML = html;
</script>


// 实际问题
{{each str}}
        <li class="media">
            <img class="mr-3" src="avatar.png" ">
            <div class=" media-body ">
                <h4>{{$value.name}}</h4>
                <p>{{$value.content}}</p>
            </div>
        </li>
{{/each}}

 var str1 = template('set', {
        str: data
});
  
 ul = str1;
```

* 循环

```js
{{each 循环的数组}}
	{{$index}}----数组的下标
	{{$value}}----数组的值
{{/each}}

```



## 同步与异步

* 同步；就是同一个时间点做一件事
* 异步：同一时间点做了几件事

> ajax就是异步请求，代码从上到下执行的时候，遇到ajax请求，就去服务器请求去了，去干别的事了，但是下边的代码还继续执行。



> 同步的话，只能干一件事，如果onload事件放在了send后边，等请求完了之后，发现这个事件没有注册，再往下走的话，发现才注册，但是已经过了触发的时机了；如果写在send之前，事先已经注册了onload事件，所以就会触发



> xhr.open(请求方式，接口地址，true/false)；第三个参数true表示异步请求，默认就是true；如果为false，就是同步请求。但是不要使用同步请求。



onprogress事件，表示数据正在接收的时候，会触发，但是触发的次数有多次

onloadstart请求开始

onloadend当ajax请求结束的时候，会触发，但是请求成功与不成功都会触发

onload请求成功触发，和onloadend相比较

## XHR对象其他其他APi

### readyState和onreadystatechange

* readyState

xhr对象提供了一个属性readyState，有五个阶段



